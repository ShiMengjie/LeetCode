# 回溯算法

## 介绍

回溯算法（backtrack）是一种搜索查找算法，它枚举所有可能的情况，在枚举所有可能情况的过程中，判断当前情况是否满足要求，如果满足就添加到解集中。

## 要素

回溯算法会把搜索过程中的所有可能情况，以“树”的形式组织起来，称为“**空间状态树**”。回溯算法开始时，从根节点开始遍历该节点下所有“**路径**”，每个路径是一个可能的解。当达到“**结束条件**”时，如果路径满足要求就会把这个路径添加到解集中，否则就回退到上一个节点（这个动作称为“回溯”）。

这种“当前路径走不通，就回退一步再走另一条路径”的方法，就是“**回溯法**”，回溯到的某个节点被称为“回溯点”。



回溯算法与“暴力搜索”：

“回溯算法”与“暴力搜索”相似，但是它与一般“暴力搜索”不同的是：回溯算法以“深度优先”的方式遍历“空间状态树”，当其中某个节点所在路径不通时，就不再遍历它的子节点和路径，提前结束该节点下的无效搜索。



回溯算法主要应用场景：

在给定的元素集合中，寻找满足条件的解集，比如求解某个“组合”、求解“排列”这种问题，这类问题一般可以通过“暴露搜索”求解。

## 模板

回溯算法的一般步骤：

1、先确定问题的输入，一般是一个有限集合，然后把问题的解集表示成“空间状态树”的形式

2、以深度优先的方式遍历“空间状态树”，以”递归函数”的形式表示遍历过程

3、当达到结束条件时，结束遍历或回退到上一个节点：

* 如果是结束遍历，且路径满足问题要求，就保存进结果集
* 如果是回退到上一个节点，就从路径中撤销在上个节点做的操作



回溯算法需要确定的几个要素：

1、**选择列表**：在什么范围内进行遍历

2、**结束条件**：达到什么条件时，结束遍历

3、**路径**：记录已经选择“路径”

4、**选择**：满足什么条件时，要把当前节点添加进路径



回溯算法一般使用“递归”的形式实现，伪代码如下：

```java
// 1、结果集
result = []
// 2、路径
path = []
// 3、选择列表、输入
nums = []

// 递归实现
backtrack(result, path, nums) {
    if('满足结束条件'):
        // 满足“要求”，把路径添加进结果集
        result.push(path)
        return
    
    for "选择" in nums:{
        // 对选择列表中，一个满足条件的“选择”，添加进路径
        "做选择"
        
        // 递归调用
        backtrack(result, path, nums)

        // 递归调用结束，说明发生了回溯，要撤销递归之前做的选择，这样才不会影响同一层的其他选择
        "撤销选择"
    }
}
```



如下图所示，是在数组`[2,3,5]`中寻找和值等于 8 的不重复组合，每个元素可以重复使用：

![img](https://cdn.jsdelivr.net/gh/shimengjie/image-repo/img/8dd61c5c430c620da2fd99b1935d166c.png)



## 参考阅读

1、[五大基本算法之回溯算法 backtracking](https://houbb.github.io/2020/01/23/data-struct-learn-07-base-backtracking)