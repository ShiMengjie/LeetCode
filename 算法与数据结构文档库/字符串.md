# 字符串



## 全排列

对N个不同的元素，组成的所有序列集合就是**全排列，**例如，“1,2,3”的全排列为：

> [1,2,3]，[1,3,2]，[2,1,3]，[2,3,1]，[3,1,2]，[3,2,1]

常用的实现算法有递归法和字典序算法。

### 递归法

给定n个元素，其全排列的递归过程可以描述如下：

① 任意取一个元素放在第一个位置；

② 对剩下的n-1个元素进行全排列，可以看作是对n-1个元素进行全排列；

③ 重复②步，直到最后只剩下一个元素；

④ 重复① ② ③步，直到所有元素都在第一个位置放置过，全排列结束。

以数组[1,2,3]为例，其全排列的递归过程如下：

① 取1放在第一个位置，后面连接着（2,3）的全排列：

- （2,3）的全排列：
  取2放在第一位，只剩下3，形成序列：[1,2,3]
  取3放在第一位，只剩下2，形成序列：[1,3,2]

② 取2放在第一个位置，后面连接着（1,3）的全排列：

- （1,3）的全排列：
  取1放在第一位，只剩下3，形成序列：[2,1,3]
  取3放在第一位，只剩下1，形成序列：[2,3,1]

③ 取3放在第一个位置，后面连接着（1,2）的全排列：

- （1,2）的全排列：
  取1放在第一位，只剩下2，形成序列：[3,1,2]
  取2放在第一位，只剩下1，形成序列：[3,2,1]

```java
/**
 * 输入n个元素，返回全排列结果
 *
 * @param chs  元素数组
 * @param low  起始下标
 * @param high 终止下标
 */
public <T> void permutationByRecur(T[] chs, int low, int high) {
    // 在数组chs[low,high]中，依次把下标为low,low+1,....,high的数值放在第一位，再对剩下的元素递归排列
    // 递归结束条件：low == high
    if (low == high) {
        for (T ch : chs) {
            System.out.print(ch);
        }
        System.out.println();
    }
    // 递归执行内容
    for (int i = low; i <= high; i++) {
        // 把下标i处的元素和下标low处的元素交换位置
        swap(chs, i, low);
        // 对剩下的元素进行递归
        permutationByRecur(chs, low + 1, high);
        // 把下标i处的元素和下标low处的元素再交换回来，准备下一次的交换
        swap(chs, i, low);
    }
}

/**
 * 交换两个下标的元素位置
 */
private <T> void swap(T[] nums, int idx1, int idx2) {
    T tmp = nums[idx1];
    nums[idx1] = nums[idx2];
    nums[idx2] = tmp;
}
```

很显然，递归实现难以理解，而且每一个组合就需要开一个方法栈，对于长度为$n$的数组，一共有$n!$种排列组合，也就是要开同样多个的栈，很容易造成内存溢出。

### 字典序算法

**字典序算法**强调不同排列之间的相对位置关系，所有排列按照一定规则有序放置。

排序规则是：从左向右依次比较相同位置处的元素，如果当前位置对应元素相同，则继续比较下一个位置，直到第一个元素不同的位置为止，元素值大的排列在字典序中的位置在元素值小的排列后面。



**字典序生成全排列的过程：**

① 将N个元素从小到大递增排序，形成有序序列，这是字典中最小的排列![img](https://cdn.nlark.com/yuque/__latex/7fc56270e7a70fa81a5935b72eacbe29.svg)；

② 在![img](https://cdn.nlark.com/yuque/__latex/7fc56270e7a70fa81a5935b72eacbe29.svg)的有序部分，寻找最后一个满足![img](https://cdn.nlark.com/yuque/__latex/8f7959d60087e1f6b58af46b5624f38c.svg)的元素![img](https://cdn.nlark.com/yuque/__latex/8a6b5ab46e06fa60418f7c34e624b076.svg)；

③ 在![img](https://cdn.nlark.com/yuque/__latex/4f586fb24de583f0a1fc2e058e17b872.svg)范围内找到大于![img](https://cdn.nlark.com/yuque/__latex/8a6b5ab46e06fa60418f7c34e624b076.svg)的最小数![img](https://cdn.nlark.com/yuque/__latex/0c41c78a817aa659629bcf6f8782858f.svg)，交换![img](https://cdn.nlark.com/yuque/__latex/8a6b5ab46e06fa60418f7c34e624b076.svg)与![img](https://cdn.nlark.com/yuque/__latex/0c41c78a817aa659629bcf6f8782858f.svg)；

④ 对![img](https://cdn.nlark.com/yuque/__latex/4f586fb24de583f0a1fc2e058e17b872.svg)范围内的元素进行翻转，得到字典序中的下一个序列；

⑤ 重复步骤②~④，直到所有元素按照从大到小逆序排列，全排列完成。

字典序生成全排列类似于动态规划，根据已知的第一个序列，生成下一个序列，生成下一个序列的时间复杂度为![img](https://cdn.nlark.com/yuque/__latex/33697ce7dfa48ba80980d298c8089378.svg)。



**算法理解：**

1、“顺序”和“逆序”是字典序中的开始和结束，对于中间的一个普通序列，如何找到它下一个序列？

下一个序列应该是尽可能接近当前序列，在交换数值时，应该**尽量保持高位不变，低位在最小的范围内交换数值位置**。



2、在什么范围内交换低位的数值？

在字典序的规则中，相同位置上数值较大的序列在后面，因此应该是在当前序列上，把有序部分的倒数第二位与大于它的最小数值交换位置，比如在数组![img](https://cdn.nlark.com/yuque/__latex/b9e56d24640a33a3c3717f35c9a193d6.svg)中：

- 有序部分满足条件：![img](https://cdn.nlark.com/yuque/__latex/e33239ed2eabcaa5a98b036cc415a511.svg)
- 逆序部分满足条件：![img](https://cdn.nlark.com/yuque/__latex/01da73ea5d53a8c33feb37e405068879.svg)

因此交换![img](https://cdn.nlark.com/yuque/__latex/0c41c78a817aa659629bcf6f8782858f.svg)和![img](https://cdn.nlark.com/yuque/__latex/8a6b5ab46e06fa60418f7c34e624b076.svg)。



3、为什么要把![img](https://cdn.nlark.com/yuque/__latex/2166643182423732cf853694c7a3ae7d.svg)范围内的数？

因为交换![img](https://cdn.nlark.com/yuque/__latex/0c41c78a817aa659629bcf6f8782858f.svg)和![img](https://cdn.nlark.com/yuque/__latex/8a6b5ab46e06fa60418f7c34e624b076.svg)之后，![img](https://cdn.nlark.com/yuque/__latex/2166643182423732cf853694c7a3ae7d.svg)范围内依然是逆序的，通过翻转，可以保证在新排列大于原来排列（![img](https://cdn.nlark.com/yuque/__latex/8a6b5ab46e06fa60418f7c34e624b076.svg)位置上的值变大了）的条件下，使得变化的幅度尽可能小。



动图演示如下：

![image](https://cdn.jsdelivr.net/gh/shimengjie/image-repo/img/1622897549803-0229fef1-6ffe-483e-b63b-78271a3aa1af.gif)

```java
public static void nextPermutation(int[] nums) {
    int len = nums.length;
    // 从前向后找到最后一组正序，代码比较难写，因此等价于从后向前找第一组逆序
    int i = len - 2;
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }
    // 翻转倒序数组
    if (i < 0) {
        reverse(nums, 0, len - 1);
        return;
    }
    // 从后向前找到大于 nums[i] 的最小的数
    int j = len - 1;
    while (j > i + 1 && nums[j] <= nums[i]) {
        j--;
    }
    swap(nums, i, j);
    reverse(nums, i + 1, len - 1);
}

/**
     * 翻转数组
     *
     * @param arr   数组
     * @param begin 开始下标
     * @param end   结束下标
     */
private static void reverse(int[] arr, int begin, int end) {
    while (begin < end) {
        swap(arr, begin, end);
        begin++;
        end--;
    }
}

/**
     * 交换数组中的两个元素
     *
     * @param nums 数组
     * @param idx1 下标1
     * @param idx2 下标2
     */
private static void swap(int[] nums, int idx1, int idx2) {
    int tmp = nums[idx1];
    nums[idx1] = nums[idx2];
    nums[idx2] = tmp;
}
```